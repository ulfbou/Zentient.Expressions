name: CI/CD

permissions:
  contents: write
  packages: write

on:
  push:
    branches: [ develop, 'release/*' ]
    tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ main ]
  workflow_dispatch: {}

env:
  SOLUTION: Zentient.Expressions.sln
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_NOLOGO: true

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  ci:
    name: Build & Test (${{ matrix.dotnet-version }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        dotnet-version: [ '8.0.x', '9.0.x' ]
    timeout-minutes: 40
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET SDK (matrix)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ matrix.dotnet-version }}

      - name: Ensure .NET 9.0.100 installed (satisfy global.json)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.100

      - name: Cache NuGet packages
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ matrix.dotnet-version }}-${{ hashFiles('**/*.csproj', '**/Directory.Pack.props', '**/Directory.Build.props') }}
          restore-keys: |
            ${{ runner.os }}-nuget-

      - name: Restore dependencies
        run: dotnet restore ${{ env.SOLUTION }}

      - name: Quick packability validation (non-fatal)
        run: |
          set -euo pipefail
          echo "Checking IsPackable flags (warnings only)"
          missing=0
          for proj in $(git ls-files 'src/**/*.csproj' 'src/*.csproj'); do
            if ! grep -q '<IsPackable>true</IsPackable>' "$proj"; then
              echo "WARNING: $proj missing explicit <IsPackable>true</IsPackable>"
              missing=1
            fi
          done
          for tproj in $(git ls-files 'tests/**/*.csproj' 'tests/*.csproj'); do
            if ! grep -q '<IsPackable>false</IsPackable>' "$tproj"; then
              echo "WARNING: test project $tproj missing explicit <IsPackable>false</IsPackable>"
              missing=1
            fi
          done
          if [ $missing -eq 1 ]; then
            echo "Packability check produced warnings; see repo policy. This does not block CI."
          fi

      - name: Build solution
        run: dotnet build ${{ env.SOLUTION }} --configuration Release --no-restore

      - name: Run tests
        run: dotnet test ${{ env.SOLUTION }} --configuration Release --no-build --logger trx --results-directory tests/TestResults || (echo "Tests failed" && exit 1)

      - name: Upload test results
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ matrix.dotnet-version }}
          path: tests/TestResults/

  pack:
    name: Pack NuGet Packages
    needs: ci
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      version: ${{ steps.set_version.outputs.version }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup .NET SDK (use 9.0.100 for packing)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.100

      - name: Also install .NET 8.0 SDK (required to build net8.0 outputs)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Restore
        run: dotnet restore ${{ env.SOLUTION }}

      - name: Install GitVersion
        uses: GitTools/actions/gitversion/setup@v0.9.14
        with:
          versionSpec: '5.x'

      - name: Run GitVersion
        id: gitversion
        uses: GitTools/actions/gitversion/execute@v0.9.14

      - name: Persist computed version
        id: set_version
        run: |
          set -euo pipefail
          echo "GitVersion outputs:"
          echo "  SemVer: ${{ steps.gitversion.outputs.SemVer }}"
          echo "  NuGetVersionV2: ${{ steps.gitversion.outputs.NuGetVersionV2 }}"
          ver=${{ steps.gitversion.outputs.NuGetVersionV2 }}
          # Fallback to SemVer if NuGetVersionV2 not available
          if [ -z "$ver" ]; then ver=${{ steps.gitversion.outputs.SemVer }}; fi
          ver=$(printf "%s" "$ver" | tr -d '\r')

          # If this is a release/* branch, require a prerelease label (no pure X.Y.Z allowed)
          if [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
            if echo "$ver" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
              echo "ERROR: Computed version for release branch is a full release ($ver). Aborting to avoid publishing a full release from a prerelease branch." >&2
              exit 1
            fi
          fi

          echo "version=$ver" >> $GITHUB_OUTPUT
          echo "$ver" > version.txt
          echo "Written version.txt:"; cat version.txt
          echo "---- debug: repo state ----"
          echo "GITHUB_REF=${GITHUB_REF}"
          echo "GITHUB_SHA=${GITHUB_SHA}"
          git --no-pager log -1 --pretty=oneline || true
          echo "Listing src/:"; ls -la src || true
          echo "---- debug: dotnet --info ----"
          dotnet --info || true

      - name: Verify version consistency (optional)
        run: |
          set -euo pipefail
          ver=${{ steps.set_version.outputs.version }}
          echo "Using version: $ver"
          # If this run was triggered by a tag, ensure tag version matches GitVersion
          if [[ "${{ github.ref }}" == refs/tags/* ]]; then
            tag=${GITHUB_REF#refs/tags/}
            if [[ "$tag" != "$ver" && "$tag" != "v$ver" ]]; then
              echo "Tag ($tag) does not match computed version ($ver)"; exit 1
            fi
          fi

      - name: Create artifacts dir
        run: mkdir -p artifacts

      - name: Build solution for packing
        run: |
          set -euo pipefail
          echo "Building solution before packing to ensure artifacts exist"
          dotnet --info
          dotnet build ${{ env.SOLUTION }} -c Release

      - name: Pack projects (use GitVersion-generated version)
        run: |
          set -euo pipefail
          set -x
          # Normalize version to a valid SemVer token (strip noise/concatenation)
          ver_raw=$(tr -d '\r\n' < version.txt)
          echo "Raw version: '$ver_raw'"
          ver_norm=$(echo "$ver_raw" | grep -oE '[0-9]+\.[0-9]+\.[0-9]+(?:[-+A-Za-z0-9.]+)?' | head -n1 || true)
          if [ -n "$ver_norm" ]; then
            ver="$ver_norm"
          else
            ver="$ver_raw"
          fi
          echo "Using normalized version: '$ver'"
          echo "$ver" > version.txt

          # Derive VersionPrefix as the base X.Y.Z to satisfy Directory.Core.targets
          base_ver=$(echo "$ver" | grep -oE '^[0-9]+\.[0-9]+\.[0-9]+' || true)
          if [ -z "$base_ver" ]; then
            echo "ERROR: Failed to extract base version (VersionPrefix) from computed version: '$ver'" >&2
            echo "Ensure GitVersion is configured to produce a numeric SemVer (e.g. 1.2.3 or 1.2.3-pr.1)" >&2
            exit 1
          fi
          echo "Derived VersionPrefix: $base_ver"

          echo "---- debug: environment ----"
          env | sort
          echo "---- debug: git status ----"
          git status --porcelain || true
          echo "---- debug: list top-level files ----"
          ls -la || true
          echo "---- debug: list src files ----"
          ls -la src || true
          echo "---- debug: version.txt contents ----"
          cat version.txt || true

          mkdir -p artifacts
          failed=0
          for proj in $(git ls-files 'src/**/*.csproj' 'src/*.csproj'); do
            if grep -q '<IsPackable>true</IsPackable>' "$proj"; then
              echo "Packing project: $proj with Version: '$ver' and VersionPrefix: '$base_ver'."
              dotnet pack "$proj" -c Release -p:Version="$ver" -p:PackageVersion="$ver" -p:VersionPrefix="$base_ver" --include-symbols --include-source -o artifacts || { echo "Pack failed for $proj"; failed=1; }
            else
              echo "Skipping non-packable project: $proj"
            fi
          done
          if [ "$failed" -ne 0 ]; then
            echo "One or more projects failed to pack"; exit 1
          fi

          # Copy version metadata into artifacts so downstream jobs can read it
          if [ -f version.txt ]; then
            cp version.txt artifacts/version.txt || true
            echo "Copied version.txt to artifacts/version.txt"
          else
            echo "version.txt not found; cannot copy"; exit 1
          fi

          echo "Packed artifacts:"; ls -la artifacts || true
          echo "---- debug: inspect nuspecs ----"
          for f in artifacts/*.nupkg; do
            echo "-- $f --"
            unzip -p "$f" *.nuspec || true

            # Validate that package contains both net8.0 and net9.0 outputs
            echo "Validating frameworks in $f"
            if unzip -l "$f" | grep -q "lib/net8.0/" && unzip -l "$f" | grep -q "lib/net9.0/"; then
              echo "Package $f contains net8.0 and net9.0"
            else
              echo "ERROR: Package $f is missing net8.0 or net9.0 outputs" >&2
              failed=1
            fi
          done || true

          if [ "$failed" -ne 0 ]; then
            echo "One or more package validation checks failed"; exit 1
          fi

      - name: Upload NuGet packages as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nuget-packages
          path: artifacts/

  sign-symbols:
    name: Sign symbol packages (optional)
    needs: pack
    runs-on: ubuntu-latest
    timeout-minutes: 20
    env:
      SIGNING_KEY: ${{ secrets.SIGNING_KEY }}
      SIGNING_PASSWORD: ${{ secrets.SIGNING_PASSWORD }}
    steps:
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages
          path: ./artifacts

      - name: Setup .NET SDK (for signing)
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.100

      - name: Sign packages and symbols (if signing key present)
        run: |
          set -euo pipefail
          if [ -z "${SIGNING_KEY:-}" ]; then
            echo "No SIGNING_KEY configured; skipping signing steps."
            exit 0
          fi

          echo "Decoding signing certificate"
          printf '%s' "$SIGNING_KEY" | base64 -d > signing-cert.pfx
          chmod 600 signing-cert.pfx

          TIMESTAMP_SERVER="http://timestamp.digicert.com"

          echo "Signing NuGet packages and symbol packages using dotnet nuget sign"
          for pkg in artifacts/*.nupkg; do
            if [ -f "$pkg" ]; then
              echo "Signing package: $pkg"
              dotnet nuget sign "$pkg" \
                --certificate-path signing-cert.pfx \
                --certificate-password "${SIGNING_PASSWORD:-}" \
                --timestamper "$TIMESTAMP_SERVER" || echo "Warning: signing failed for $pkg"
            fi
          done

          for sym in artifacts/*.snupkg; do
            if [ -f "$sym" ]; then
              echo "Signing symbol package: $sym"
              dotnet nuget sign "$sym" \
                --certificate-path signing-cert.pfx \
                --certificate-password "${SIGNING_PASSWORD:-}" \
                --timestamper "$TIMESTAMP_SERVER" || echo "Warning: signing failed for $sym"
            fi
          done

          echo "Verifying signatures (best effort)"
          for pkg in artifacts/*.nupkg; do
            if [ -f "$pkg" ]; then
              echo "Signatures for $pkg:"
              dotnet nuget verify "$pkg" -Signatures || true
            fi
          done

          # Remove sensitive material
          shred -u signing-cert.pfx || rm -f signing-cert.pfx || true
          echo "Signing complete"

  publish:
    name: Publish to NuGet & Create Release
    needs: [ pack, sign-symbols ]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    timeout-minutes: 20
    steps:
      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages
          path: ./artifacts

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.100

      - name: Push packages to NuGet.org (packages and symbols)
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          set -euo pipefail
          pushed=0
          for pkg in artifacts/*.nupkg; do
            if [ -f "$pkg" ]; then
              dotnet nuget push "$pkg" --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate || { echo "Failed to push $pkg"; exit 1; }
              pushed=$((pushed+1))
            fi
          done
          for sym in artifacts/*.snupkg; do
            if [ -f "$sym" ]; then
              dotnet nuget push "$sym" --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate || { echo "Failed to push symbol $sym"; exit 1; }
            fi
          done
          if [ "$pushed" -eq 0 ]; then
            echo "No packages found to push."; exit 1
          fi

      - name: Prepare release assets
        run: |
          set -euo pipefail
          mkdir -p release_assets
          shopt -s nullglob || true
          for pkg in artifacts/*.nupkg; do
            cp "$pkg" release_assets/ || true
          done
          for sym in artifacts/*.snupkg; do
            cp "$sym" release_assets/ || true
          done
          if [ -f CHANGELOG.md ]; then
            cp CHANGELOG.md release_assets/CHANGELOG.md
          else
            echo "Release triggered by $GITHUB_REF" > release_assets/CHANGELOG.md
          fi
          if [ -f LICENSE ]; then
            cp LICENSE release_assets/LICENSE
          else
            echo "MIT License - placeholder" > release_assets/LICENSE
          fi
          for f in src/*/README.md; do
            if [ -f "$f" ]; then cp "$f" release_assets/; fi
          done

      - name: Create GitHub Release and attach artifacts
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release_assets/*
          body_path: release_assets/CHANGELOG.md
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout repository for retry tagging
        if: ${{ failure() }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create and push retry tag
        if: ${{ failure() }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          timestamp=$(date -u +%Y%m%d%H%M%S)
          newtag="v1.0.0-retry.${timestamp}"
          git config user.email "actions@github.com"
          git config user.name "github-actions[bot]"
          git tag -f "$newtag"
          git push --force origin "refs/tags/$newtag"

  publish-prerelease:
    name: Publish Prerelease from release/* (alfa/beta/rc)
    needs: [ pack, sign-symbols ]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/heads/release/')
    timeout-minutes: 20
    steps:
      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: nuget-packages
          path: ./artifacts

      - name: Determine version and tag
        run: |
          set -euo pipefail
          ver="${{ needs.pack.outputs.version }}"
          tag="v${ver}"
          echo "Version=$ver" > release_meta.txt
          echo "Tag=$tag" >> release_meta.txt
          cat release_meta.txt

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.100

      - name: Optionally push prerelease packages to NuGet (if API key configured)
        env:
          NUGET_API_KEY: ${{ secrets.NUGET_API_KEY }}
        run: |
          set -euo pipefail
          if [ -z "${NUGET_API_KEY:-}" ]; then
            echo "No NUGET_API_KEY configured; skipping nuget push for prerelease.";
            exit 0;
          fi
          pushed=0
          for pkg in artifacts/*.nupkg; do
            if [ -f "$pkg" ]; then
              dotnet nuget push "$pkg" --api-key "$NUGET_API_KEY" --source https://api.nuget.org/v3/index.json --skip-duplicate || echo "Failed to push $pkg (non-fatal for prerelease)"
              pushed=$((pushed+1)) || true
            fi
          done
          echo "Pushed $pushed packages (or attempted)."

      - name: Create tag for prerelease
        run: |
          set -euo pipefail
          echo "Tag creation from CI is disabled for this workflow (skipping)."

      - name: Prepare release assets
        run: |
          set -euo pipefail
          mkdir -p release_assets
          shopt -s nullglob || true
          for pkg in artifacts/*.nupkg; do
            cp "$pkg" release_assets/ || true
          done
          for sym in artifacts/*.snupkg; do
            cp "$sym" release_assets/ || true
          done
          if [ -f CHANGELOG.md ]; then
            cp CHANGELOG.md release_assets/CHANGELOG.md
          else
            echo "Prerelease triggered by $GITHUB_REF" > release_assets/CHANGELOG.md
          fi
          if [ -f LICENSE ]; then
            cp LICENSE release_assets/LICENSE
          else
            echo "MIT License - placeholder" > release_assets/LICENSE
          fi
          for f in src/*/README.md; do
            if [ -f "$f" ]; then cp "$f" release_assets/; fi
          done

      - name: Create GitHub prerelease and attach artifacts
        uses: softprops/action-gh-release@v2
        with:
          files: |
            release_assets/*
          body_path: release_assets/CHANGELOG.md
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
